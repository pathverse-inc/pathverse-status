name: Health Updater

on:
  schedule:
    - cron: '*/30 * * * *'  # Every 30 minutes
  workflow_dispatch:  # Allow manual trigger

jobs:
  api-health-check:
    uses: ./.github/workflows/api-health-check.yml
  
  api-degradation:
    uses: ./.github/workflows/compute-degradation.yml
    with:
      issue_label: 'project_api'
      verbose: false
  
  webapp-health-check:
    uses: ./.github/workflows/webapp-health-check.yml
  
  webapp-degradation:
    uses: ./.github/workflows/compute-degradation.yml
    with:
      issue_label: 'project_webapp'
      verbose: false
  
  update-status-files:
    needs: [api-health-check, api-degradation, webapp-health-check, webapp-degradation]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Update issues.json and status.json
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Helper function to update issues for a service
            function updateIssuesForService(issues, degradationData) {
              const { open_ids, closed_ids, format_down_ids, descriptions } = degradationData;
              
              // Remove closed issues
              issues = issues.filter(issue => {
                if (issue.id && closed_ids.includes(issue.id)) {
                  console.log(`Removing closed issue: ${issue.id}`);
                  return false;
                }
                return true;
              });
              
              // Process open issues
              open_ids.forEach(id => {
                const existingIssue = issues.find(i => i.id === id);
                const issueDesc = descriptions.find(d => d.id === id);
                const isFormatDown = format_down_ids.includes(id);
                
                if (!existingIssue) {
                  const newIssue = {
                    id: id,
                    type: 'error',
                    message: issueDesc ? issueDesc.description : 'Issue details not available'
                  };
                  
                  if (isFormatDown) {
                    newIssue.down = true;
                  }
                  
                  console.log(`Adding new issue: ${id}`);
                  issues.push(newIssue);
                } else {
                  if (issueDesc) {
                    existingIssue.message = issueDesc.description;
                  }
                  
                  if (isFormatDown) {
                    existingIssue.down = true;
                  } else {
                    delete existingIssue.down;
                  }
                  
                  console.log(`Updated issue: ${id}`);
                }
              });
              
              return issues;
            }
            
            // Read current files
            let issues = JSON.parse(fs.readFileSync('./public/issues.json', 'utf8'));
            let status = JSON.parse(fs.readFileSync('./public/status.json', 'utf8'));
            
            // Get health check results
            const apiHealth = parseInt('${{ needs.api-health-check.outputs.status }}');
            const webappHealth = parseInt('${{ needs.webapp-health-check.outputs.status }}');
            
            // Get degradation data
            const apiData = {
              open_ids: ${{ needs.api-degradation.outputs.open_ids }},
              closed_ids: ${{ needs.api-degradation.outputs.closed_ids }},
              format_down_ids: ${{ needs.api-degradation.outputs.format_down_ids }},
              descriptions: ${{ needs.api-degradation.outputs.issue_descriptions }},
              score: parseInt('${{ needs.api-degradation.outputs.degradation_score }}')
            };
            
            const webappData = {
              open_ids: ${{ needs.webapp-degradation.outputs.open_ids }},
              closed_ids: ${{ needs.webapp-degradation.outputs.closed_ids }},
              format_down_ids: ${{ needs.webapp-degradation.outputs.format_down_ids }},
              descriptions: ${{ needs.webapp-degradation.outputs.issue_descriptions }},
              score: parseInt('${{ needs.webapp-degradation.outputs.degradation_score }}')
            };
            
            // Update issues.json
            issues = updateIssuesForService(issues, apiData);
            issues = updateIssuesForService(issues, webappData);
            
            // Update status.json
            
            // Calculate status values
            const apiStatus = apiHealth === 0 ? 0 : 100 - apiData.score;
            const webappStatus = webappHealth === 0 ? 0 : 100 - webappData.score;
            
            console.log(`API health: ${apiHealth}, degradation: ${apiData.score}, status: ${apiStatus}`);
            console.log(`Webapp health: ${webappHealth}, degradation: ${webappData.score}, status: ${webappStatus}`);
            
            // Update status arrays: remove first value, add new value at the end
            status.api.shift();
            status.api.push(apiStatus);
            
            status.webapp.shift();
            status.webapp.push(webappStatus);
            
            // Write updated files
            fs.writeFileSync('./public/issues.json', JSON.stringify(issues, null, 4));
            console.log('✅ issues.json updated');
            
            fs.writeFileSync('./public/status.json', JSON.stringify(status, null, 4));
            console.log('✅ status.json updated');
      
      - name: Commit and Push Changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add public/issues.json public/status.json
          git diff --staged --quiet || git commit -m "chore: update status files [skip ci]"
          git push
  
  deploy:
    needs: update-status-files
    uses: ./.github/workflows/create-deploy-pr.yml
    with:
      approve: true
